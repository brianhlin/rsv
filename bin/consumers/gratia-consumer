#!/usr/bin/env python

""" This script processes records and uploads them to the Gratia collector """

import os
import sys


def initialize():
    """ Check that environment is valid """

    info = {}

    log("Gratia consumer initializing...")

    if "VDT_LOCATION" not in os.environ:
        die("ERROR: VDT_LOCATION must be set in the environment")

    info["vdt_location"] = os.environ["VDT_LOCATION"]

    if not os.path.exists(info["vdt_location"]):
        die("ERROR: VDT_LOCATION is set to a non-existent value: '%s'" % info["vdt_location"])

    info["output_dir"] = os.path.join(info["vdt_location"], "osg-rsv", "output", "gratia-consumer")
    info["failed_dir"] = os.path.join(info["vdt_location"], "osg-rsv", "output", "failed-gratia-records")

    # TODO - make this a configuration setting
    info["gratia_config_file"] = os.path.join(info["vdt_location"], "gratia", "probe", "metric", "ProbeConfig")

def load_gratia_libraries(info):
    """ Import the Gratia libraries """

    sys.path.prepend(os.path.join(info["vdt_location"], "gratia", "probe", "metric"))
    sys.path.prepend(os.path.join(info["vdt_location"], "gratia", "probe", "common"))

    try:
        import Gratia
        import Metric
    except ImportError, err:
        print "ERROR: Could not import Gratia python libraries: %s" % err
        print "\nsys.path:"
        print "\n".join(sys.path)
        die("")

def process_files(info):
    """ Open the records directory and load each file """

    Gratia.Initialize(info["gratia_config_file"])

    files = os.listdir(info["output_dir"])
    log("Processing %s files" % len(files))
    for file in files:
        fh = open(file, 'r')
        record = fh.read()
        fh.close()
        gratia_record = generate_gratia_record(record)

        error_msg = Gratia.Send(gratia_record)
        if not error_msg:
            try:
                os.remove(file)
            except OSError, err:
                # If we cannot remove the files then we are going to process them again
                # So stop processing now to avoid duplicate data.
                die("ERROR: Failed to remove record '%s'.  Error: %s" % (file, err))
        else:
            # TODO Move to the failed-gratia-records directory


def process_recrd(full_record):
    """ Process a record in WLCG format """
    record = parse_wlcg_record(full_record)

    # TODO - check that record is valid

    # This code is based on the Python scripts RSV generates
    rec = Metric.MetricRecord()
    rec.MetricName(record["metricName"])
    rec.MetricType(record["metricType"])
    rec.MetricStatus(record["metricStatus"])
    rec.Timestamp(record["timestamp"])
    rec.ServiceType(record["serviceType"])
    rec.SummaryData(record["summaryData"])
    rec.DetailsData(record["detailsData"])

    # serviceUri and gatheredAt will be on "non-local" metrics
    if "serviceUri" in record and "gatheredAt" in record:
        rec.ServiceUri(record["serviceUri"])
        rec.GatheredAt(record["gatheredAt"])
    # And hostName will be in "local" metrics
    elif "hostName" in record:
        rec.HostName(record["hostName"])

    return rec


def parse_wlcg_record(record):
    """ Parse a record in WLCG format and return a dict with values.  Example of WLCG record:

    metricName: org.osg.general.ping-host
    metricType: status
    timestamp: 2010-08-21T17:47:08Z
    metricStatus: OK
    serviceType: OSG-CE
    serviceURI: osg-edu
    gatheredAt: vdt-itb.cs.wisc.edu
    summaryData: OK
    detailsData: Host osg-edu is alive and responding to pings!
    EOT

    Note: for local probe serviceURI and gatheredAt are replaced by hostName

    """


    pass

def log(msg):
    """ Print a message with a timestamp """
    timestamp = "TODO: "
    print "%s %s" % (timestamp, msg)

def die(msg):
    """ Print an error message and exit with a non-zero status """
    print msg
    sys.exit(1)



info = initialize()
load_gratia_libraries(info)
proess_records(info)
