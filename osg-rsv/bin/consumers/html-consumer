#!/usr/bin/env python

""" This script processes records generates a local HTML page for viewing results """

import os
import re
import sys
import time
import popen2
import pickle
import signal
import ConfigParser
from time import strftime
from optparse import OptionParser

# Holds all the metric info.  This is a multi-level data structure with the following
# format:
#   <Host> -> {}
#             <Metric> -> {}
#                         time   = Last time metric ran
#                         status = Last status of metric
#                         history -> []
#                                    <full text of record>
#                                    <full text of record>
#                                    ...
#            <Metric2> -> {}
#                         ...
#  <Host2> -> {}
#             ...
STATE = {}

ALERTS = []
OPTIONS = None
CONSUMER_DONE = 0

class InvalidRecordError(Exception):
    """ Custom exception for a bad record format """
    pass


def main():
    initialize()
    load_state_file()
    process_files()
    get_job_info()
    generate_html_files()
    write_state_file()
    sys.exit(0)


def initialize():
    """ Check that environment is valid """

    usage = """usage: html-consumer
      --vdt-location <VDT directory>
      --output-dir <HTML directory>
      --max-history <Number of historical entries>
      --help | -h 
      --version
    """

    version = "html-consumer 4.0"
    description = "This script processes RSV records and generates an HTML status page."

    parser = OptionParser(usage=usage, description=description, version=version)
    parser.add_option("--vdt-location", dest="vdt_location", default=None,
                      help="Root directory of the OSG installation", metavar="DIR")
    parser.add_option("--output-dir", dest="output-dir", default=None,
                      help="Directory to store HTML output", metavar="DIR")
    parser.add_option("--max_history", dest="max_history", default=20, type="int",
                      help="Number of historical entries to store for each metric.", metavar="SIZE")
    parser.add_option("--record_trim_length", dest="record_trim_length", type="int", default=10000,
                      help="Size in bytes to trim each record.  Default=%default", metavar="LENGTH" )

    global OPTIONS
    (OPTIONS, args) = parser.parse_args()

    #
    # Validate VDT-LOCATION
    #
    if not OPTIONS.vdt_location:
        if "VDT_LOCATION" not in os.environ:
            die("ERROR: VDT_LOCATION must be set in the environment or passed on the command line.")
        else:
            OPTIONS.vdt_location = os.environ["VDT_LOCATION"]

    if not os.path.exists(OPTIONS.vdt_location):
        die("ERROR: VDT_LOCATION is set to a non-existent directory: '%s'" % OPTIONS.vdt_location)

    OPTIONS.rsv_location = os.path.join(OPTIONS.vdt_location, "osg-rsv")

    #
    # Open a file for logging all output.  If we print all output to STDOUT it will end up in
    # a file that Condor will overwrite every time this script executes, so we'll move it to
    # a more permanent log file and rotate it manually.
    #
    log_file = os.path.join(OPTIONS.rsv_location, "logs", "consumers", "html-consumer.output")
    OPTIONS.log = open(log_file, 'a')

    log("html-consumer initializing.")

    # Where records will be read from
    # This script will delete files from this directory, so it also needs write access.
    OPTIONS.records_dir = os.path.join(OPTIONS.rsv_location, "output", "html-consumer")
    if not os.access(OPTIONS.records_dir, os.F_OK):
        die("ERROR: Records directory does not exist '%s'" % OPTIONS.records_dir)
    if not os.access(OPTIONS.records_dir, os.R_OK):
        die("ERROR: Cannot read records directory '%s'" % OPTIONS.records_dir)
    if not os.access(OPTIONS.records_dir, os.W_OK):
        die("ERROR: Cannot write records directory '%s'" % OPTIONS.records_dir)

    # Validate the HTML output directory and create it if necessary
    OPTIONS.output_dir = os.path.join(OPTIONS.rsv_location, "output", "html")
    if not os.access(OPTIONS.output_dir, os.F_OK):
        log("Directory for HTML output does not exist at %s.  Creating it." % OPTIONS.output_dir)
        try:
            os.mkdir(OPTIONS.output_dir, 0755)
        except OSError, err:
            die("ERROR: Could not create directory.  Error: %s" % err)
    if not os.access(OPTIONS.output_dir, os.R_OK):
        die("ERROR: Cannot read HTML output directory '%s'" % OPTIONS.output_dir)
    if not os.access(OPTIONS.output_dir, os.W_OK):
        die("ERROR: Cannot write HTML output directory '%s'" % OPTIONS.output_dir)

    # Catch some signals and exit gracefully if we get them
    signal.signal(signal.SIGINT, sigterm_handler)
    signal.signal(signal.SIGTERM, sigterm_handler)

    return


def get_state_file_path():
    """ Returns the path of the state file """
    return os.path.join(OPTIONS.output_dir, "state.file")


def load_state_file():
    """ Process the HTML state file """

    global ALERTS
    state_file = get_state_file_path()

    if not os.path.exists(state_file):
        log("State file does not exist.")
        return

    try:
        state_file_fp = open(state_file, 'r')
    except IOError, err:
        # If we can't read/write to the state file we won't be able to save any
        # results, but we should still write an HTML page with the problem.
        msg = "Error trying to load state file - %s" % err
        log(msg)
        ALERTS.append(msg)
        return

    try:
        global STATE
        STATE = pickle.load(state_file_fp)
    except EOFError, err:
        # Should this be a warning?
        log("State file is empty")
    except pickle.UnpicklingError, err:
        msg = "Error loading state file - %s" % err
        log(msg)
        # We should assume nobody will ever read the log file.  Push all error
        # messages to the web page for higher visibility.
        ALERTS.append(msg)
        
    return


def write_state_file():
    """ Save the state back to disk """

    state_file = get_state_file_path()

    state_fp = open(state_file, 'w')
    pickle.dump(STATE, state_fp)
    state_fp.close()

    return


def process_files():
    """ Open the records directory and load each file """

    files = os.listdir(OPTIONS.records_dir)
    log("Processing %s files" % len(files))
    for filename in files:
        if CONSUMER_DONE == 1:
            break
        
        success = 0

        file = os.path.join(OPTIONS.records_dir, filename)
        fh = open(file, 'r')
        record = fh.read()
        fh.close()

        if not record or record.isspace():
            log("The record in %s is empty.  Removing file." % filename)
        else:
            try:
                process_record(record)
            except InvalidRecordError, err:
                log("Error processing record: %s\nFull record:\n%s" % (err, record))

        try:
            os.remove(file)
        except OSError, err:
            # If we cannot remove the files then we are going to process them again
            # So stop processing now to avoid duplicate data.
            die("ERROR: Failed to remove record '%s'.  Error: %s" % (file, err))

    return


def parse_wlcg_record(raw_record):
    """ Parse a record in WLCG format and return a dict with values.  For the html-consumer
    the timestamp will be in seconds since the epoch.  Example of WLCG record:

    metricName: org.osg.general.ping-host
    metricType: status
    timestamp: 1287068818
    metricStatus: OK
    serviceType: OSG-CE
    serviceURI: osg-edu
    gatheredAt: vdt-itb.cs.wisc.edu
    summaryData: OK
    detailsData: Host osg-edu is alive and responding to pings!
    EOT

    Note: for local probe serviceURI and gatheredAt are replaced by hostName

    """

    record = {}

    # detailsData will always come last, and might be multiple lines
    # Keep state so that once we are in the detailsData section, we put the rest of the
    # lines into detailsData and return when we see EOT
    in_details_data = 0
    for line in raw_record.split('\n'):
        if not in_details_data:
            match = re.match("(\w+):(.*)$", line)
            if match:
                record[match.group(1)] = match.group(2).strip()
                if match.group(1) == "detailsData":
                    in_details_data = 1
            else:
                raise InvalidRecordError("Invalid line:\n\t%s" % line)
        else:
            if re.match("EOT$", line):
                if "serviceURI" in record:
                    record["serviceURI"] = re.sub(":", "_", record["serviceURI"])
                elif "hostName" in record:
                    record["hostName"] = re.sub(":", "_", record["hostName"])
                return record
            else:
                record["detailsData"] += line

    # If we reach this point, it means we did not see EOT.  So the record is invalid
    raise InvalidRecordError("'EOT' marker missing")


def process_record(raw_record):
    """ Process a record in WLCG format """

    record = parse_wlcg_record(raw_record)

    #
    # Check that we got the values we are expecting
    #
    for attribute in ("metricName", "metricType", "metricStatus", "timestamp", "serviceType",
                      "summaryData", "detailsData"):
        if attribute not in record:
            raise InvalidRecordError("Missing %s" % attribute)

    # We need to have either (hostName) or (serviceURI + gatheredAt)
    host = None
    if "serviceURI" in record and "gatheredAt" in record:
        host = record["serviceURI"]
    elif "hostName" in record:
        host = record["hostName"]
    else:
        raise InvalidRecordError("Missing either hostName or (serviceURI + gatheredAt)")


    #
    # Update the state
    #
    metric = record["metricName"]

    global STATE
    if host not in STATE:
        STATE[host] = {}

    # Set the top-level metric info
    if metric not in STATE[host]:
        STATE[host][metric] = {}
    STATE[host][metric]["time"]   = float(record["timestamp"])
    STATE[host][metric]["status"] = record["metricStatus"]
    STATE[host][metric]["next"]   = "UNKNOWN"

    # Add an item to the history.  We could either do a history based on the number
    # of records kept (for each metric) or based on an expiration date since the record
    # was generated.  I'm picking the easier approach for now of just keeping an absolute
    # number.
    trimmed_record = raw_record[:OPTIONS.record_trim_length]

    if "history" not in STATE[host][metric]:
        STATE[host][metric]["history"] = []
    
    STATE[host][metric]["history"].insert(0, trimmed_record)
    if len(STATE[host][metric]["history"]) > OPTIONS.max_history:
        STATE[host][metric]["history"] = STATE[host][metric]["history"][0:OPTIONS.max_history]

    return


def get_job_info():
    """ Figure out if any jobs are missing """

    rsv_control = os.path.join(OPTIONS.vdt_location, "osg-rsv", "bin", "rsv-control")
    try:
        (ret, out, err) = system("%s -j --parsable" % rsv_control, 15)
    except TimeoutError:
        log("ERROR: rsv-control timed out while trying to get job information")
        return

    if ret != 0:
        log("ERROR: Could not get job information from rsv-control")
        log("STDOUT:\n%s" % out)
        log("STDERR:\n%s" % err)

    host = ""
    for line in out.split("\n"):
        match = re.match("Hostname: (\S+)", line)
        if match:
            host = match.group(1)
            continue

        # For now we'll just drop any lines for hosts we don't know anything about
        if host not in STATE:
            continue

        match = re.match("MISSING: (.+)", line)
        if match:
            missing_metrics = match.group(1).split('|')
            ALERTS.append("On host %s there are %s metrics enabled that are not running: %s" %
                          (host, len(missing_metrics), " ".join(missing_metrics)))

        arr = line.split('|')
        if len(arr) == 5:
            metric = arr[4].strip()
            if metric in STATE[host]:
                next_run_time = arr[3].strip()
                STATE[host][metric]["next"] = next_run_time


def generate_html_files():
    """ Write out the top-level HTML file and any host-specific files """

    main_page = html_template()

    # Fill in the basics
    timestamp = strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    title = "RSV Main Status - %s" % timestamp
    header = "RSV Main Status :: %s" % timestamp
    main_page = re.sub("!!TITLE!!", title, main_page)
    main_page = re.sub("!!HEADER!!", header, main_page)

    # Add in any alerts
    alerts = ""
    for alert in ALERTS:
        alerts += "<p class=\"alert\">WARNING: %s\n" % alert

    main_page = re.sub("!!ALERTS!!", alerts, main_page)

    # Generate a table for each host
    tables = ""
    if len(STATE) == 0:
        tables = "<p>There is no data to display.</p>"
    else:
        for host in sorted(STATE.keys()):
            generate_host_html(host, STATE[host])
            host_table = html_table_template()
            host_table = re.sub("!!HOSTNAME!!", host, host_table)
            rows = []
            for metric in sorted(STATE[host]):
                link        = "%s.html#%s" % (host, metric)
                id          = STATE[host][metric]["status"].lower()
                pretty_time = strftime("%Y-%m-%d %H:%M:%S %Z", time.localtime(STATE[host][metric]["time"]))

                row  = "<tr id='%s'><td style='text-align:left'><a href='%s'>%s</a></td><td>%s</td><td>%s</td><td>%s</td></tr>" %\
                       (id, link, metric, pretty_time, STATE[host][metric]["next"], STATE[host][metric]["status"])
                rows.append(row)

            table = '\n'.join(rows)
            host_table = re.sub("!!ROWS!!", table, host_table)
            tables += host_table
        
    main_page = re.sub("!!TABLES!!", tables, main_page)

    # There is no data for the main HTML page.  This section is only used for the
    # host-specific pages
    main_page = re.sub("!!DATA!!", "", main_page)

    try:
        main_html_file = os.path.join(OPTIONS.output_dir, "index.html")
        fp = open(main_html_file, 'w')
        fp.write(main_page)
        fp.close()
    except IOError, err:
        log("Error writing main HTML file '%s': %s" % (main_html_file, err))

    return


def generate_host_html(host, info):
    """ Create the host-specific HTML file """

    host_page = html_template()

    # Fill in the basics
    timestamp = strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    title = "RSV Status - %s - %s" % (host, timestamp)
    header = "RSV Status :: %s :: %s" % (host, timestamp)
    host_page = re.sub("!!TITLE!!", title, host_page)
    host_page = re.sub("!!HEADER!!", header, host_page)

    # Add in any alerts
    alerts = ""
    for alert in ALERTS:
        alerts += "<p class=\"alert\">WARNING: %s\n" % alert

    host_page = re.sub("!!ALERTS!!", alerts, host_page)

    # Generate a table for the host, and display each historical result
    table = ""
    data = ""
    if len(info) == 0:
        table = "<p>There is no data to display.</p>"
    else:
        host_table = html_table_template()
        host_table = re.sub("!!HOSTNAME!!", host, host_table)
        rows = []
        for metric in sorted(info):
            link        = "#%s" % metric
            id          = info[metric]["status"].lower()
            pretty_time = strftime("%Y-%m-%d %H:%M:%S %Z", time.localtime(info[metric]["time"]))
            
            row  = "<tr id='%s'><td style='text-align:left'><a href='%s'>%s</a></td><td>%s</td><td>%s</td><td>%s</td></tr>" %\
                   (id, link, metric, pretty_time, info[metric]["next"], info[metric]["status"])
            rows.append(row)

            data += "<a name='%s'></a><h2>%s</h2>\n" % (metric, metric)
            for entry in info[metric]["history"]:
                data += "<pre>%s</pre>\n" % entry

        table = re.sub("!!ROWS!!", '\n'.join(rows), host_table)
        
    host_page = re.sub("!!TABLES!!", table, host_page)
    host_page = re.sub("!!DATA!!", data, host_page)

    try:
        host_html_file = os.path.join(OPTIONS.output_dir, "%s.html" % host)
        fp = open(host_html_file, 'w')
        fp.write(host_page)
        fp.close()
    except IOError, err:
        log("Error writing main HTML file '%s': %s" % (host_html_file, err))

    return


def log(msg):
    """ Print a message with a timestamp """
    timestamp = strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    print "%s: %s" % (timestamp, msg)

    if OPTIONS.log:
        OPTIONS.log.write("%s: %s\n" % (timestamp, msg))
        

def die(msg):
    """ Print an error message and exit with a non-zero status """
    log(msg)
    sys.exit(1)


def sigterm_handler(signum, frame):
    """ The handler for SIGTERM and SIGKILL """
    log("Caught signal #%s.  Exiting after processing current record." % signum)
    global CONSUMER_DONE
    CONSUMER_DONE = 1
    return


def html_template():
    """ Returns the HTML template file """

    return """<html>
   <head>
      <title>!!TITLE!!</title>
      <style type='text/css'>
      <!--
      pre {
         margin-left: 1em;
         margin-right: 1em;
         padding: 0.5em;
         background-color: #f0f0f0;
         border: 1px solid black;
      }
      body { 
         color: black;
         background-color: white;
      }
      #links_table { border: 1px solid black; width: 100%; text-align: center; }
      a:link {background: none; color: #000000; text-decoration: underline}
      a:visited {background: none; color: #000000; text-decoration: underline}
      a:hover {background: #000000; color: #FFFFFF; text-decoration: underline}

      #ok { background-color: #8ae234; }
      #warning { background-color: #fce94f; }
      #critical { background-color: #ef2929; }
      #unknown { background-color: #eeeeec; }

      .question { cursor:pointer; text-decoration:underline; }
      .visible { display: block }
      .invisible { display: none }

      p.alert { background-color: red }
      -->
      </style>

      </script>
   </head>

   <body>
     <table>
       <tr>
         <td><a href='http://www.opensciencegrid.org' title='Open Science Grid'><img src='http://vdt.cs.wisc.edu/pictures/osg_logo.gif' border='0'></a></td>
         <td align='center'><h1>!!HEADER!!</h1></td>
       </tr>
    </table>
    !!ALERTS!!
    <p><a href=\"#legend\">Explanation of colors</a>
    <p>
    !!TABLES!!
    !!DATA!!

   <p>&nbsp;<p><a name=\"legend\">Legend:</a>
   <table>
     <tr id=\"ok\"><td>The metric ran successfully</td></tr>
     <tr id=\"warning\"><td>The metric produced some warnings</td></tr>
     <tr id=\"critical\"><td>The metric failed</td></tr>
     <tr id=\"unknown\"><td>The metric produced an unknown result</td></tr>
   </table>
   </body>
</html>
"""

def html_table_template():
    """ Return the HTML table template """
    return """<p>
      <table id='links_table'>
         <tr colspan=4>!!HOSTNAME!!</tr>
         <tr>
            <th>Metric</th>
            <th>Last Executed</th>
            <th>Approximate Next Run Time</th>
            <th>Status</th>
         </tr>
         !!ROWS!!
      </table>
      """



class TimeoutError(Exception):
    """ This defines an Exception that we can use if our system call times out """
    pass

def alarm_handler(signum, frame):
    raise TimeoutError("System call timed out")

def system(command, timeout):
    """ Run a system command with a timeout specified (in seconds).
    Returns:
    1) exit code
    2) STDOUT
    3) STDERR
    
    I think this could possibly be better done using the subprocess module, but
    that requires Python 2.4 and we need to support Python 2.3+.
    """
    
    try:
        signal.signal(signal.SIGALRM, alarm_handler)
        signal.alarm(timeout)
        child = popen2.Popen3(command, capturestderr=1)
        ret = child.wait()
        signal.alarm(0)
    except TimeoutError:
        log("ERROR", "Command timed out (timeout=%s): %s" % (timeout, command))
        os.kill(child.pid, signal.SIGKILL)
        raise TimeoutError("Command timed out (timeout=%s)" % timeout)
    
    out = child.fromchild.read()
    err = child.childerr.read()
    return (ret, out, err)



main()
