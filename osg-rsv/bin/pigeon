#!/usr/bin/env python

import os
import re
import sys
import popen2
import signal
import random
import tempfile
import ConfigParser
from optparse import OptionParser

def process_options(arguments=None):
    """ Handle the command line options """

    usage = """usage: pigeon
    --vo
    TODO - fill this in
    """
    
    description = "TODO - Fill in the description here"

    parser = OptionParser(usage=usage, description=description)
    parser.add_option("--vo", dest="vo", default="Engage", # TODO - default should not be Engage?
                      help="The VO to get SEs for")
    parser.add_option("--verbose", dest="verbose", default=False,
                       help="Enable verbose output")

    if arguments == None:
        (options, args) = parser.parse_args()
    else:
        (options, args) = parser.parse_args(arguments)

    return options, args


class TimeoutError(Exception):
    """ This defines an Exception that we can use if our system call times out """
    pass
            
def alarm_handler(signum, frame):
    raise TimeoutError("System call timed out")


def system(command, timeout=300):
    """ Run a system command with a timeout specified (in seconds).
    Returns:
    1) exit code
    2) STDOUT
    3) STDERR
    
    I think this could possibly be better done using the subprocess module, but
    that requires Python 2.4 and we need to support Python 2.3+.
    """

    try:
        signal.signal(signal.SIGALRM, alarm_handler)
        signal.alarm(timeout)
        child = popen2.Popen3(command, capturestderr=1)
        ret = child.wait() & 0xff
        signal.alarm(0)
    except TimeoutError:
        os.kill(child.pid, signal.SIGKILL)
        raise TimeoutError("Command timed out (timeout=%s)" % timeout)

    out = child.fromchild.read()
    err = child.childerr.read()
    return (ret, out, err)


def query_bdii(options, sUrl=0, tUrl=0):
    """ Use the storage discovery tools to find SEs """

    se_list = {}


    if sUrl == 1:
        print "Querying BDII for SEs for VO %s..." % options.vo
        command = "get_surl --vo %s --show_storage_element_id" % options.vo
    elif tUrl == 1:
        # TODO - Clarify this comment.  What's a "classic" SE vs an SE?
        print "Querying BDII for classic SEs for VO %s..." % options.vo
        command = "get_gridftp_url --vo %s --show_storage_element_id" % options.vo
        
    (ret, out, err) = system(command)

    if ret != 0:
        print "ERROR: command returned a non-zero exit status"
        print "command: %s" % command
        print "STDOUT: %s\n\n" % out
        print "STDERR: %s" % err
        sys.exit(1)

    for line in out.split("\n"):
        # Ignore the header line which looks like this:
        # STORAGE ELEMENT ID            SURL
        if line.find("STORAGE ELEMENT ID") >= 0:
            continue
            
        # A line will look like this:
        # bsrm-1.t2.ucsd.edu   srm://bsrm-1.t2.ucsd.edu:8443/srm/v2/server?SFN=/hadoop/engage/TESTFILE
        fields = re.split("\s+", line)
        if len(fields) >= 2:
            srm_id   = fields[0].strip()
            srm_dest = fields[1].strip()
            srm_dest = re.sub("TESTFILE", "TESTFILE-RSV", srm_dest)

            # TODO: Preserving this from the original pigeon probe, I'm not sure why it is needed
            if tUrl == 1:
                srm_dest += str(random.randint(0, 10000))

            # We will need to call discovery tools again in order to get the site name.              
            command = "get_site_name_for_seid --storage_element_id %s" % srm_id
            (ret, out, err) = system(command)
            if ret != 0:
                print "ERROR: Failed to get site name for storage element ID '%s'.  Skipping this site" % srm_id
                continue

            name = re.sub('"', '', out)

            # If the command returns multiple names (I'm looking at you disapprovingly, BNL-ATLAS)
            # then only take the first one.  
            name = re.sub("\s+.*$", "", name)

            print "%s %s %s" % (name, srm_id, srm_dest)
            match = re.match("srm://([^/]+)/(.+)\?SFN=(.+)$", srm_dest) # TODO - did I parse this right?  SFN= in particular?
            if match:
                se_list[name] = { "host" : srm_id }
                se_list[name]["host-with-port"]  = match.group(1)
                se_list[name]["webservice-path"] = match.group(2)
                se_list[name]["dir"]             = match.group(3)
            else:
                print "ERROR: Could not parse srm destination '%s'" % srm_dest
                continue

    print "Found %s SEs" % len(se_list.keys())
    return se_list


def make_ini_file(metrics, srm_dir, srm_webservice_path):
    """ Generate a temporary INI file to be used with rsv-control """

    config = ConfigParser.RawConfigParser()

    for metric in metrics:
        section = "%s args" % metric
        config.add_section(section)
        config.set(section, "srm-dir", srm_dir)
        config.set(section, "srm-webservice-path", srm_webservice_path)

    # Write out to a temporary INI file that is on the filesystem
    handle = tempfile.NamedTemporaryFile(prefix="pigeon.", suffix=".ini")
    config.write(handle)
    handle.file.flush()
    return handle
          

def probe_surls(se_list, options):
    """ Run RSV metrics against the SEs we discovered """

    for name in se_list.keys():
        se = se_list[name]
        print "Monitoring SE %s (%s)" % (name, se["host"])

        # Note: only SRM metrics should be used because we pass the host-with-port below
        # which means that a metric such as org.osg.general.ping-host would fail unless
        # the ping succeeded against the specific port (if specificed in BDII)
        # TODO - list metrics here
        metrics = ["org.osg.srm.srmclient-ping"]

        # Write an INI file
        config_file = make_ini_file(metrics, se["dir"], se["webservice-path"])

        command = "rsv-control -r -u %s --extra-config-file %s %s" %\
                  (se["host-with-port"], config_file.name, " ".join(metrics))
        
        (ret, out, err) = system(command)

        if ret != 0:
            print "ERROR: rsv-control failed to run metrics against host %s" % se["host"]
            print "STDOUT: %s\n\n" % out
            print "STDERR: %s" % err
            continue
        else:
            # When successful the output should contain the metric record
            print out


def probe_turls():
    # TODO - this should look like probe_surls
    pass


random.seed()
options, args = process_options()
surl_list = query_bdii(options, sUrl=1)
#turl_list = query_bdii(options, tUrl=1)

# Probe
probe_surls(surl_list, options)
#probe_turls(turl_list, options)
