#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use File::Basename;

use lib qw(/usr/libexec/rsv/probes);
use RSVMetric;

print_output_header();

my $OPT_HOSTNAME;
my $OPT_METRIC;
my $OPT_DEST_DIR = "/tmp";
my $OPT_DELAY = 30;

GetOptions("u=s"               => \$OPT_HOSTNAME,
           "m=s"               => \$OPT_METRIC,
           "destination-dir=s" => \$OPT_DEST_DIR,
           "delay=i"           => \$OPT_DELAY,
           "help|usage"        => \&usage);

#
# Set up file paths
#
my $test_file = "/usr/share/rsv/probe-helper-files/gridftp-probe-test-file";
my $local_uri = "file://$test_file";

if(!-e $test_file) {
    print "CRITICAL\n";
    print "The helper file is missing from '$test_file'.\n";
    print "Your RSV installation may be incomplete or corrupt.\n";
    exit 0;
}

my $time = time;
my $remote_file = basename($test_file) . ".$time.$$";
my $remote_uri = "gsiftp://$OPT_HOSTNAME/$OPT_DEST_DIR/$remote_file";


# 
# Transfer to
#
my $cmd = "globus-url-copy $local_uri $remote_uri 2>&1";
my $out = `$cmd`;
if($? != 0) {
    print "CRITICAL\n";
    print "Failed to transfer to remote host.\n";
    print "Command: $cmd\n";
    print "Output:\n$out\n";
    exit 0;
}
else {
    print STDERR "Successful transfer to remote host.\n";
    print STDERR "Command: $cmd\n";
    print STDERR "Output:\n$out\n\n";
}

# The previous RSV developer (Arvind Gopu) said that this probe fails to find
# the remote file unless a delay is implemented between transfers.
sleep($OPT_DELAY);

#
# Transfer from
#
my $new_local_path = "/tmp/$remote_file";
my $new_local_uri = "file://$new_local_path";
$cmd = "globus-url-copy $remote_uri $new_local_uri 2>&1";
$out = `$cmd`;
if($? != 0) {
    print "CRITICAL\n";
    print "Successful transfer to remote host.\n";
    print "Failed to transfer from remote host.\n";
    print "Command: $cmd\n";
    print "Output:\n$out\n";
    cleanup_files();
    exit 0;
}
elsif(!-e $new_local_path) {
    print "CRITICAL\n";
    print "Successful transfer to remote host.\n";
    print "When transferring the file back from the remote host, globus-url-copy\n";
    print "returned an exit status of 0 (no error) but the file does not exist locally\n";
    print "Command: $cmd\n";
    print "Output:\n$out\n";
    cleanup_files();
    exit 0;
}
else {
    print STDERR "Successful transfer from remote host.\n";
    print STDERR "Command: $cmd\n";
    print STDERR "Output:\n$out\n\n";
}

#
# Compare files
#
$out = `diff $test_file $new_local_path 2>&1`;
if($? != 0) {
    print "CRITICAL\n";
    print "Successful transfer to remote host.\n";
    print "Successful transfer from remote host.\n";
    print "The file that was returned from the remote host does not match the original file.\n";
    print "Diff:\n$out\n";
    cleanup_files();
    exit 0;
}

print "OK\n";
print "Successful transfer to remote host.\n";
print "Successful transfer from remote host.\n";
print "Original file and received file are identical.\n";
cleanup_files();
exit 0;

sub usage {
    print STDERR "Usage: $0\n";
    print STDERR "\t-u <hostname>\n";
    print STDERR "\t-m <metric>\n";
    print STDERR "\t--destination-dir <remote dir, default=/tmp>\n";
    print STDERR "\t--delay <delay between transfers in seconds>\n\n";
    exit 1;
}

sub cleanup_files {
    # First cleanup the local file if it exists
    if($new_local_path and -e $new_local_path) {
        if(not unlink($new_local_path)) {
            print STDERR "Failed to unlink existing local file '$new_local_path': $!";
        }
    }

    # Then cleanup the remote file using UberFTP
    my $out = `uberftp -rm $remote_uri 2>&1`;
    if($? != 0) {
        print STDERR "Failed to remove remote file '$remote_uri'.  Output:\n$out\n";
    }
}
